#pragma once
#include <memory>
#include <vector>

class NeuralWaveFunction
{
public:
    NeuralWaveFunction(std::unique_ptr<class Random> rng);
    // Use the default deconstructor generated by the compiler
    virtual ~NeuralWaveFunction() = default;

    const int &getNumberOfHiddenNodes() { return m_numberOfHiddenNodes; }

    const std::vector<std::vector<double>> &getVisibleBias() { return m_visibleBias; }
    const std::vector<double> &getHiddenBias() { return m_hiddenBias; }
    const std::vector<std::vector<std::vector<double>>> &getWeights() { return m_weights; }

    virtual void setVisibleBias(std::vector<std::vector<double>> visibleBias) = 0;
    virtual void setHiddenBias(std::vector<double> hiddenBias) = 0;
    virtual void setWeights(std::vector<std::vector<std::vector<double>>> weights) = 0;

    virtual double evaluate(std::vector<std::unique_ptr<class Particle>> &particles) = 0;

    virtual void computeParamDerivative(std::vector<std::unique_ptr<class Particle>> &particles,
                                        std::vector<std::vector<std::vector<double>>> &weightDeltaPsi,
                                        std::vector<std::vector<double>> &visDeltaPsi,
                                        std::vector<double> &hidDeltaPsi) = 0;

    virtual std::vector<double> Qfac(std::vector<std::unique_ptr<class Particle>> &particles) = 0;
    virtual void quantumForce(std::vector<std::unique_ptr<class Particle>> &particles, Particle &particle, std::vector<double> &force) = 0;
    virtual double computeWeightNorms() = 0;

protected:
    std::unique_ptr<class Random> m_rng;
    int m_numberOfHiddenNodes = 0;
    int m_numberOfParticles = 0;
    int m_numberOfDimensions = 0;
    double m_sigma = 0;

    std::vector<std::vector<std::vector<double>>> m_weights;
    std::vector<std::vector<double>> m_visibleBias;
    std::vector<double> m_hiddenBias;
};